import argparse
import os
import re
import shutil
import tarfile
from typing import Dict, List

import jinja2
import requests
import yaml
from pydriller import RepositoryMining


def get_remote_packages_information(
        remote_packages_file: str) -> Dict[str, str]:
    packages_file_request = requests.get(remote_packages_file)
    packages_file_split = re.split('\n\n', packages_file_request.text)
    remote_packages_current: Dict[str, str] = {}
    for packages_file_split_part in packages_file_split:
        package_name = re.search(
            'Package: ([a-z0-9-]*)',
            packages_file_split_part)
        package_version = re.search(
            'Version: ([a-z0-9.+-:]*)',
            packages_file_split_part)
        if package_name is not None and package_version is not None:
            remote_packages_current[package_name.group(
                1)] = package_version.group(1)
    return remote_packages_current


def get_local_packages_metadata(local_packages: List[str]) -> Dict[str, dict]:
    local_package_metadata: Dict[str, dict] = {}
    for local_package in local_packages:
        with open(f'{local_package}/metadata.yml') as project_metadata_file:
            project_metadata = yaml.load(
                project_metadata_file, Loader=yaml.SafeLoader)
        if project_metadata.get('version_git_autogenerated', False):
            project_metadata['version'] = get_local_current_version(
                project_metadata['directory_name'])
        local_package_metadata[project_metadata['package_name']
                               ] = project_metadata
    return local_package_metadata


def get_local_current_version(directory_name: str) -> str:
    commits = list(
        RepositoryMining(
            ".",
            filepath=directory_name).traverse_commits())
    commits.reverse()
    return f"0.git.r{len(commits)}.{commits[0].hash[:7]}"


def build_orig_tarballs(
        packages: List[str], packages_metadata: Dict[str, dict]):
    for package in packages:
        package_metadata = packages_metadata[package]
        with tarfile.open(f"build/{package}_{package_metadata['version']}.orig.tar.xz", "x:xz") as orig_tarball:
            for file in package_metadata['files']:
                orig_tarball.add(
                    f"{package_metadata['directory_name']}/{file['src']}",
                    arcname=file['src'])


def generate_changelog(package_metadata: dict) -> List[dict]:
    changelog: List[dict] = []
    commits = list(
        RepositoryMining(
            ".",
            filepath=package_metadata['directory_name']).traverse_commits())
    for commit_enum in enumerate(commits, start=1):
        commit = commit_enum[1]
        changelog.append({
            "version_code": f"0.git.r{commit_enum[0]}.{commit.hash[:7]}-1",
            "changelog": "* " + re.split("\n", commit.msg)[0],
            "date": commit.committer_date.strftime("%a, %d %b %Y %H:%M:%S %z")
        })
    changelog.reverse()
    return changelog


def template_debian_files(
        packages: List[str], packages_metadata: Dict[str, dict], project_metadata: dict):
    for package in packages:
        package_metadata = packages_metadata[package]

        try:
            os.makedirs(
                f"build/{package_metadata['package_name']}/debian/source")
        except FileExistsError:
            pass

        # Changelog
        changelog_template = jinja2.Template(
            open(os.path.dirname(os.path.abspath(__file__)) + '/templates/debian/changelog.j2').read()
        ).render(
            versions=generate_changelog(package_metadata),
            maintainer=project_metadata['maintainer'],
            package_name=package_metadata['package_name'])
        with open(f"build/{package}/debian/changelog", 'w') as file:
            file.write(changelog_template)

        # Control
        control_template = jinja2.Template(
            open(os.path.dirname(os.path.abspath(__file__)) + '/templates/debian/control.j2').read()
        ).render(
            versions=generate_changelog(package_metadata),
            maintainer=project_metadata['maintainer'],
            package_name=package_metadata['package_name'],
            package_dependencies=package_metadata['dependencies'],
            package_description=package_metadata['description'])
        with open(f"build/{package}/debian/control", 'w') as file:
            file.write(control_template)

        # Copyright
        copyright_template = jinja2.Template(
            open(os.path.dirname(os.path.abspath(__file__)) + '/templates/debian/copyright.j2').read()
        ).render(
            source_maintainer=package_metadata['source_maintainer'],
            source_license=package_metadata['source_license'],
            maintainer=project_metadata['maintainer'])
        with open(f"build/{package}/debian/copyright", 'w') as file:
            file.write(copyright_template)

        # Rules
        rules_template = jinja2.Template(
            open(os.path.dirname(os.path.abspath(__file__)) + '/templates/debian/rules.j2').read()
        ).render(
            package_files=package_metadata['files'],
            package_name=package_metadata['package_name'])
        with open(f"build/{package}/debian/rules", 'w') as file:
            file.write(rules_template)

        # Compat
        compat_template = jinja2.Template(
            open(
                os.path.dirname(
                    os.path.abspath(__file__)) +
                '/templates/debian/compat.j2').read()).render()
        with open(f"build/{package}/debian/compat", 'w') as file:
            file.write(compat_template)

        # source/format
        compat_template = jinja2.Template(
            open(
                os.path.dirname(
                    os.path.abspath(__file__)) +
                '/templates/debian/source/format.j2').read()).render()
        with open(f"build/{package}/debian/source/format", 'w') as file:
            file.write(compat_template)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-p',
        '--packages',
        action="append",
        type=str,
        help='List of packages. For multiple packages use argument multiple times. Default is all changed packages')
    args = parser.parse_args()

    try:
        os.mkdir("build")
    except FileExistsError:
        shutil.rmtree("build")
        os.mkdir("build")

    with open('metadata.yml') as project_metadata_file:
        project_metadata = yaml.load(
            project_metadata_file,
            Loader=yaml.SafeLoader)
    packages_to_build: List[str] = args.packages
    local_packages_metadata: Dict[str, dict] = get_local_packages_metadata(
        project_metadata['packages'])
    if packages_to_build is None:
        packages_to_build = []
        remote_packages_current: Dict[str, str] = get_remote_packages_information(
            project_metadata['remote_repository']['packages_file'])

        for local_package in local_packages_metadata.values():
            if local_package['version'] > remote_packages_current[local_package['package_name']]:
                packages_to_build.append(local_package['package_name'])

    build_orig_tarballs(packages_to_build, local_packages_metadata)
    template_debian_files(
        packages_to_build,
        local_packages_metadata,
        project_metadata)


if __name__ == '__main__':
    main()
